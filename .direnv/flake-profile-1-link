{
  "bashFunctions": {
    "_accumFlagsArray":" \n    local name;\n    if [ -n \"$__structuredAttrs\" ]; then\n        for name in \"$@\";\n        do\n            local -n nameref=\"$name\";\n            flagsArray+=(${nameref+\"${nameref[@]}\"});\n        done;\n    else\n        for name in \"$@\";\n        do\n            local -n nameref=\"$name\";\n            case \"$name\" in \n                *Array)\n                    flagsArray+=(${nameref+\"${nameref[@]}\"})\n                ;;\n                *)\n                    flagsArray+=(${nameref-})\n                ;;\n            esac;\n        done;\n    fi\n",
    "_activatePkgs":" \n    local hostOffset targetOffset;\n    local pkg;\n    for hostOffset in \"${allPlatOffsets[@]}\";\n    do\n        local pkgsVar=\"${pkgAccumVarVars[hostOffset + 1]}\";\n        for targetOffset in \"${allPlatOffsets[@]}\";\n        do\n            (( hostOffset <= targetOffset )) || continue;\n            local pkgsRef=\"${pkgsVar}[$targetOffset - $hostOffset]\";\n            local pkgsSlice=\"${!pkgsRef}[@]\";\n            for pkg in ${!pkgsSlice+\"${!pkgsSlice}\"};\n            do\n                activatePackage \"$pkg\" \"$hostOffset\" \"$targetOffset\";\n            done;\n        done;\n    done\n",
    "_addRpathPrefix":" \n    if [ \"${NIX_NO_SELF_RPATH:-0}\" != 1 ]; then\n        export NIX_LDFLAGS=\"-rpath $1/lib ${NIX_LDFLAGS-}\";\n        if [ -n \"${NIX_LIB64_IN_SELF_RPATH:-}\" ]; then\n            export NIX_LDFLAGS=\"-rpath $1/lib64 ${NIX_LDFLAGS-}\";\n        fi;\n        if [ -n \"${NIX_LIB32_IN_SELF_RPATH:-}\" ]; then\n            export NIX_LDFLAGS=\"-rpath $1/lib32 ${NIX_LDFLAGS-}\";\n        fi;\n    fi\n",
    "_addToEnv":" \n    local depHostOffset depTargetOffset;\n    local pkg;\n    for depHostOffset in \"${allPlatOffsets[@]}\";\n    do\n        local hookVar=\"${pkgHookVarVars[depHostOffset + 1]}\";\n        local pkgsVar=\"${pkgAccumVarVars[depHostOffset + 1]}\";\n        for depTargetOffset in \"${allPlatOffsets[@]}\";\n        do\n            (( depHostOffset <= depTargetOffset )) || continue;\n            local hookRef=\"${hookVar}[$depTargetOffset - $depHostOffset]\";\n            if [[ -z \"${strictDeps-}\" ]]; then\n                local visitedPkgs=\"\";\n                for pkg in \"${pkgsBuildBuild[@]}\" \"${pkgsBuildHost[@]}\" \"${pkgsBuildTarget[@]}\" \"${pkgsHostHost[@]}\" \"${pkgsHostTarget[@]}\" \"${pkgsTargetTarget[@]}\";\n                do\n                    if [[ \"$visitedPkgs\" = *\"$pkg\"* ]]; then\n                        continue;\n                    fi;\n                    runHook \"${!hookRef}\" \"$pkg\";\n                    visitedPkgs+=\" $pkg\";\n                done;\n            else\n                local pkgsRef=\"${pkgsVar}[$depTargetOffset - $depHostOffset]\";\n                local pkgsSlice=\"${!pkgsRef}[@]\";\n                for pkg in ${!pkgsSlice+\"${!pkgsSlice}\"};\n                do\n                    runHook \"${!hookRef}\" \"$pkg\";\n                done;\n            fi;\n        done;\n    done\n",
    "_allFlags":" \n    export system pname name version;\n    for varName in $(awk 'BEGIN { for (v in ENVIRON) if (v ~ /^[a-z][a-zA-Z0-9_]*$/) print v }');\n    do\n        if (( \"${NIX_DEBUG:-0}\" >= 1 )); then\n            printf \"@%s@ -> %q\\n\" \"${varName}\" \"${!varName}\";\n        fi;\n        args+=(\"--subst-var\" \"$varName\");\n    done\n",
    "_assignFirst":" \n    local varName=\"$1\";\n    local REMOVE=REMOVE;\n    shift;\n    while (( $# )); do\n        if [ -n \"${!1-}\" ]; then\n            eval \"${varName}\"=\"$1\";\n            return;\n        fi;\n        shift;\n    done;\n    echo \"Error: _assignFirst found no valid variant!\";\n    return 1\n",
    "_callImplicitHook":" \n    local def=\"$1\";\n    local hookName=\"$2\";\n    if declare -F \"$hookName\" > /dev/null; then\n        \"$hookName\";\n    else\n        if type -p \"$hookName\" > /dev/null; then\n            source \"$hookName\";\n        else\n            if [ -n \"${!hookName:-}\" ]; then\n                eval \"${!hookName}\";\n            else\n                return \"$def\";\n            fi;\n        fi;\n    fi\n",
    "_defaultUnpack":" \n    local fn=\"$1\";\n    if [ -d \"$fn\" ]; then\n        cp -pr --reflink=auto -- \"$fn\" \"$(stripHash \"$fn\")\";\n    else\n        case \"$fn\" in \n            *.tar.xz | *.tar.lzma | *.txz)\n                xz -d < \"$fn\" | tar xf - --warning=no-timestamp\n            ;;\n            *.tar | *.tar.* | *.tgz | *.tbz2 | *.tbz)\n                tar xf \"$fn\" --warning=no-timestamp\n            ;;\n            *)\n                return 1\n            ;;\n        esac;\n    fi\n",
    "_doStrip":" \n    local -ra flags=(dontStripHost dontStripTarget);\n    local -ra debugDirs=(stripDebugList stripDebugListTarget);\n    local -ra allDirs=(stripAllList stripAllListTarget);\n    local -ra stripCmds=(STRIP STRIP_FOR_TARGET);\n    local -ra ranlibCmds=(RANLIB RANLIB_FOR_TARGET);\n    stripDebugList=${stripDebugList[*]:-lib lib32 lib64 libexec bin sbin};\n    stripDebugListTarget=${stripDebugListTarget[*]:-};\n    stripAllList=${stripAllList[*]:-};\n    stripAllListTarget=${stripAllListTarget[*]:-};\n    local i;\n    for i in ${!stripCmds[@]};\n    do\n        local -n flag=\"${flags[$i]}\";\n        local -n debugDirList=\"${debugDirs[$i]}\";\n        local -n allDirList=\"${allDirs[$i]}\";\n        local -n stripCmd=\"${stripCmds[$i]}\";\n        local -n ranlibCmd=\"${ranlibCmds[$i]}\";\n        if [[ -n \"${dontStrip-}\" || -n \"${flag-}\" ]] || ! type -f \"${stripCmd-}\" 2> /dev/null; then\n            continue;\n        fi;\n        stripDirs \"$stripCmd\" \"$ranlibCmd\" \"$debugDirList\" \"${stripDebugFlags[*]:--S}\";\n        stripDirs \"$stripCmd\" \"$ranlibCmd\" \"$allDirList\" \"${stripAllFlags[*]:--s}\";\n    done\n",
    "_eval":" \n    if declare -F \"$1\" > /dev/null 2>&1; then\n        \"$@\";\n    else\n        eval \"$1\";\n    fi\n",
    "_makeSymlinksRelative":" \n    local symlinkTarget;\n    if [ -n \"${dontRewriteSymlinks-}\" ]; then\n        return 0;\n    fi;\n    while IFS= read -r -d '' f; do\n        symlinkTarget=$(readlink \"$f\");\n        if [[ \"$symlinkTarget\"/ != \"$prefix\"/* ]]; then\n            continue;\n        fi;\n        if [ ! -e \"$symlinkTarget\" ]; then\n            echo \"the symlink $f is broken, it points to $symlinkTarget (which is missing)\";\n        fi;\n        echo \"rewriting symlink $f to be relative to $prefix\";\n        ln -snrf \"$symlinkTarget\" \"$f\";\n    done < <(find $prefix -type l -print0)\n",
    "_moveLib64":" \n    if [ \"${dontMoveLib64-}\" = 1 ]; then\n        return;\n    fi;\n    if [ ! -e \"$prefix/lib64\" -o -L \"$prefix/lib64\" ]; then\n        return;\n    fi;\n    echo \"moving $prefix/lib64/* to $prefix/lib\";\n    mkdir -p $prefix/lib;\n    shopt -s dotglob;\n    for i in $prefix/lib64/*;\n    do\n        mv --no-clobber \"$i\" $prefix/lib;\n    done;\n    shopt -u dotglob;\n    rmdir $prefix/lib64;\n    ln -s lib $prefix/lib64\n",
    "_moveSbin":" \n    if [ \"${dontMoveSbin-}\" = 1 ]; then\n        return;\n    fi;\n    if [ ! -e \"$prefix/sbin\" -o -L \"$prefix/sbin\" ]; then\n        return;\n    fi;\n    echo \"moving $prefix/sbin/* to $prefix/bin\";\n    mkdir -p $prefix/bin;\n    shopt -s dotglob;\n    for i in $prefix/sbin/*;\n    do\n        mv \"$i\" $prefix/bin;\n    done;\n    shopt -u dotglob;\n    rmdir $prefix/sbin;\n    ln -s bin $prefix/sbin\n",
    "_moveSystemdUserUnits":" \n    if [ \"${dontMoveSystemdUserUnits:-0}\" = 1 ]; then\n        return;\n    fi;\n    if [ ! -e \"${prefix:?}/lib/systemd/user\" ]; then\n        return;\n    fi;\n    local source=\"$prefix/lib/systemd/user\";\n    local target=\"$prefix/share/systemd/user\";\n    echo \"moving $source/* to $target\";\n    mkdir -p \"$target\";\n    ( shopt -s dotglob;\n    for i in \"$source\"/*;\n    do\n        mv \"$i\" \"$target\";\n    done );\n    rmdir \"$source\";\n    ln -s \"$target\" \"$source\"\n",
    "_moveToShare":" \n    if [ -n \"$__structuredAttrs\" ]; then\n        if [ -z \"${forceShare-}\" ]; then\n            forceShare=(man doc info);\n        fi;\n    else\n        forceShare=(${forceShare:-man doc info});\n    fi;\n    if [[ -z \"$out\" ]]; then\n        return;\n    fi;\n    for d in \"${forceShare[@]}\";\n    do\n        if [ -d \"$out/$d\" ]; then\n            if [ -d \"$out/share/$d\" ]; then\n                echo \"both $d/ and share/$d/ exist!\";\n            else\n                echo \"moving $out/$d to $out/share/$d\";\n                mkdir -p $out/share;\n                mv $out/$d $out/share/;\n            fi;\n        fi;\n    done\n",
    "_multioutConfig":" \n    if [ \"$(getAllOutputNames)\" = \"out\" ] || [ -z \"${setOutputFlags-1}\" ]; then\n        return;\n    fi;\n    if [ -z \"$shareDocName\" ]; then\n        local confScript=\"$configureScript\";\n        if [ -z \"$confScript\" ] && [ -x ./configure ]; then\n            confScript=./configure;\n        fi;\n        if [ -f \"$confScript\" ]; then\n            local shareDocName=\"$(sed -n \"s/^PACKAGE_TARNAME='\\(.*\\)'$/\\1/p\" < \"$confScript\")\";\n        fi;\n        if [ -z \"$shareDocName\" ] || echo \"$shareDocName\" | grep -q '[^a-zA-Z0-9_-]'; then\n            shareDocName=\"$(echo \"$name\" | sed 's/-[^a-zA-Z].*//')\";\n        fi;\n    fi;\n    prependToVar configureFlags --bindir=\"${!outputBin}\"/bin --sbindir=\"${!outputBin}\"/sbin --includedir=\"${!outputInclude}\"/include --oldincludedir=\"${!outputInclude}\"/include --mandir=\"${!outputMan}\"/share/man --infodir=\"${!outputInfo}\"/share/info --docdir=\"${!outputDoc}\"/share/doc/\"${shareDocName}\" --libdir=\"${!outputLib}\"/lib --libexecdir=\"${!outputLib}\"/libexec --localedir=\"${!outputLib}\"/share/locale;\n    prependToVar installFlags pkgconfigdir=\"${!outputDev}\"/lib/pkgconfig m4datadir=\"${!outputDev}\"/share/aclocal aclocaldir=\"${!outputDev}\"/share/aclocal\n",
    "_multioutDevs":" \n    if [ \"$(getAllOutputNames)\" = \"out\" ] || [ -z \"${moveToDev-1}\" ]; then\n        return;\n    fi;\n    moveToOutput include \"${!outputInclude}\";\n    moveToOutput lib/pkgconfig \"${!outputDev}\";\n    moveToOutput share/pkgconfig \"${!outputDev}\";\n    moveToOutput lib/cmake \"${!outputDev}\";\n    moveToOutput share/aclocal \"${!outputDev}\";\n    for f in \"${!outputDev}\"/{lib,share}/pkgconfig/*.pc;\n    do\n        echo \"Patching '$f' includedir to output ${!outputInclude}\";\n        sed -i \"/^includedir=/s,=\\${prefix},=${!outputInclude},\" \"$f\";\n    done\n",
    "_multioutDocs":" \n    local REMOVE=REMOVE;\n    moveToOutput share/info \"${!outputInfo}\";\n    moveToOutput share/doc \"${!outputDoc}\";\n    moveToOutput share/gtk-doc \"${!outputDevdoc}\";\n    moveToOutput share/devhelp/books \"${!outputDevdoc}\";\n    moveToOutput share/man \"${!outputMan}\";\n    moveToOutput share/man/man3 \"${!outputDevman}\"\n",
    "_multioutPropagateDev":" \n    if [ \"$(getAllOutputNames)\" = \"out\" ]; then\n        return;\n    fi;\n    local outputFirst;\n    for outputFirst in $(getAllOutputNames);\n    do\n        break;\n    done;\n    local propagaterOutput=\"$outputDev\";\n    if [ -z \"$propagaterOutput\" ]; then\n        propagaterOutput=\"$outputFirst\";\n    fi;\n    if [ -z \"${propagatedBuildOutputs+1}\" ]; then\n        local po_dirty=\"$outputBin $outputInclude $outputLib\";\n        set +o pipefail;\n        propagatedBuildOutputs=`echo \"$po_dirty\"             | tr -s ' ' '\\n' | grep -v -F \"$propagaterOutput\"             | sort -u | tr '\\n' ' ' `;\n        set -o pipefail;\n    fi;\n    if [ -z \"$propagatedBuildOutputs\" ]; then\n        return;\n    fi;\n    mkdir -p \"${!propagaterOutput}\"/nix-support;\n    for output in $propagatedBuildOutputs;\n    do\n        echo -n \" ${!output}\" >> \"${!propagaterOutput}\"/nix-support/propagated-build-inputs;\n    done\n",
    "_overrideFirst":" \n    if [ -z \"${!1-}\" ]; then\n        _assignFirst \"$@\";\n    fi\n",
    "_pruneLibtoolFiles":" \n    if [ \"${dontPruneLibtoolFiles-}\" ] || [ ! -e \"$prefix\" ]; then\n        return;\n    fi;\n    find \"$prefix\" -type f -name '*.la' -exec grep -q '^# Generated by .*libtool' {} \\; -exec grep -q \"^old_library=''\" {} \\; -exec sed -i {} -e \"/^dependency_libs='[^']/ c dependency_libs='' #pruned\" \\;\n",
    "_updateSourceDateEpochFromSourceRoot":" \n    if [ -n \"$sourceRoot\" ]; then\n        updateSourceDateEpoch \"$sourceRoot\";\n    fi\n",
    "activatePackage":" \n    local pkg=\"$1\";\n    local -r hostOffset=\"$2\";\n    local -r targetOffset=\"$3\";\n    (( hostOffset <= targetOffset )) || exit -1;\n    if [ -f \"$pkg\" ]; then\n        source \"$pkg\";\n    fi;\n    if [[ -z \"${strictDeps-}\" || \"$hostOffset\" -le -1 ]]; then\n        addToSearchPath _PATH \"$pkg/bin\";\n    fi;\n    if (( hostOffset <= -1 )); then\n        addToSearchPath _XDG_DATA_DIRS \"$pkg/share\";\n    fi;\n    if [[ \"$hostOffset\" -eq 0 && -d \"$pkg/bin\" ]]; then\n        addToSearchPath _HOST_PATH \"$pkg/bin\";\n    fi;\n    if [[ -f \"$pkg/nix-support/setup-hook\" ]]; then\n        source \"$pkg/nix-support/setup-hook\";\n    fi\n",
    "addEnvHooks":" \n    local depHostOffset=\"$1\";\n    shift;\n    local pkgHookVarsSlice=\"${pkgHookVarVars[$depHostOffset + 1]}[@]\";\n    local pkgHookVar;\n    for pkgHookVar in \"${!pkgHookVarsSlice}\";\n    do\n        eval \"${pkgHookVar}s\"'+=(\"$@\")';\n    done\n",
    "addNodePath":" \n    addToSearchPath NODE_PATH \"$1/lib/node_modules\"\n",
    "addToSearchPath":" \n    addToSearchPathWithCustomDelimiter \":\" \"$@\"\n",
    "addToSearchPathWithCustomDelimiter":" \n    local delimiter=\"$1\";\n    local varName=\"$2\";\n    local dir=\"$3\";\n    if [[ -d \"$dir\" && \"${!varName:+${delimiter}${!varName}${delimiter}}\" != *\"${delimiter}${dir}${delimiter}\"* ]]; then\n        export \"${varName}=${!varName:+${!varName}${delimiter}}${dir}\";\n    fi\n",
    "appendToVar":" \n    local -n nameref=\"$1\";\n    useArray=;\n    if [ -n \"$__structuredAttrs\" ]; then\n        useArray=true;\n    else\n        useArray=false;\n    fi;\n    if declare -p \"$1\" 2> /dev/null | grep -q '^'; then\n        type=\"$(declare -p \"$1\")\";\n        if [[ \"$type\" =~ \"declare -A\" ]]; then\n            echo \"appendToVar(): ERROR: trying to use appendToVar on an associative array, use variable+=([\\\"X\\\"]=\\\"Y\\\") instead.\" 1>&2;\n            return 1;\n        else\n            if [[ \"$type\" =~ \"declare -a\" ]]; then\n                useArray=true;\n            else\n                useArray=false;\n            fi;\n        fi;\n    fi;\n    shift;\n    if $useArray; then\n        nameref=(${nameref+\"${nameref[@]}\"} \"$@\");\n    else\n        nameref=\"${nameref-} $*\";\n    fi\n",
    "auditTmpdir":" \n    local dir=\"$1\";\n    [ -e \"$dir\" ] || return 0;\n    header \"checking for references to $TMPDIR/ in $dir...\";\n    local i;\n    find \"$dir\" -type f -print0 | while IFS= read -r -d '' i; do\n        if [[ \"$i\" =~ .build-id ]]; then\n            continue;\n        fi;\n        if isELF \"$i\"; then\n            if { \n                printf :;\n                patchelf --print-rpath \"$i\"\n            } | grep -q -F \":$TMPDIR/\"; then\n                echo \"RPATH of binary $i contains a forbidden reference to $TMPDIR/\";\n                exit 1;\n            fi;\n        fi;\n        if isScript \"$i\"; then\n            if [ -e \"$(dirname \"$i\")/.$(basename \"$i\")-wrapped\" ]; then\n                if grep -q -F \"$TMPDIR/\" \"$i\"; then\n                    echo \"wrapper script $i contains a forbidden reference to $TMPDIR/\";\n                    exit 1;\n                fi;\n            fi;\n        fi;\n    done;\n    stopNest\n",
    "bintoolsWrapper_addLDVars":" \n    local role_post;\n    getHostRoleEnvHook;\n    if [[ -d \"$1/lib64\" && ! -L \"$1/lib64\" ]]; then\n        export NIX_LDFLAGS${role_post}+=\" -L$1/lib64\";\n    fi;\n    if [[ -d \"$1/lib\" ]]; then\n        local -a glob=($1/lib/lib*);\n        if [ \"${#glob[*]}\" -gt 0 ]; then\n            export NIX_LDFLAGS${role_post}+=\" -L$1/lib\";\n        fi;\n    fi\n",
    "buildPhase":" \n    runHook preBuild;\n    if [[ -z \"${makeFlags-}\" && -z \"${makefile:-}\" && ! ( -e Makefile || -e makefile || -e GNUmakefile ) ]]; then\n        echo \"no Makefile, doing nothing\";\n    else\n        foundMakefile=1;\n        local flagsArray=(${enableParallelBuilding:+-j${NIX_BUILD_CORES}} SHELL=$SHELL);\n        _accumFlagsArray makeFlags makeFlagsArray buildFlags buildFlagsArray;\n        echoCmd 'build flags' \"${flagsArray[@]}\";\n        make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n        unset flagsArray;\n    fi;\n    runHook postBuild\n",
    "ccWrapper_addCVars":" \n    local role_post;\n    getHostRoleEnvHook;\n    if [ -d \"$1/include\" ]; then\n        export NIX_CFLAGS_COMPILE${role_post}+=\" -isystem $1/include\";\n    fi;\n    if [ -d \"$1/Library/Frameworks\" ]; then\n        export NIX_CFLAGS_COMPILE${role_post}+=\" -iframework $1/Library/Frameworks\";\n    fi\n",
    "checkPhase":" \n    runHook preCheck;\n    if [[ -z \"${foundMakefile:-}\" ]]; then\n        echo \"no Makefile or custom checkPhase, doing nothing\";\n        runHook postCheck;\n        return;\n    fi;\n    if [[ -z \"${checkTarget:-}\" ]]; then\n        if make -n ${makefile:+-f $makefile} check > /dev/null 2>&1; then\n            checkTarget=check;\n        else\n            if make -n ${makefile:+-f $makefile} test > /dev/null 2>&1; then\n                checkTarget=test;\n            fi;\n        fi;\n    fi;\n    if [[ -z \"${checkTarget:-}\" ]]; then\n        echo \"no check/test target in ${makefile:-Makefile}, doing nothing\";\n    else\n        local flagsArray=(${enableParallelChecking:+-j${NIX_BUILD_CORES}} SHELL=$SHELL);\n        _accumFlagsArray makeFlags makeFlagsArray;\n        if [ -n \"$__structuredAttrs\" ]; then\n            flagsArray+=(\"${checkFlags[@]:-VERBOSE=y}\");\n        else\n            flagsArray+=(${checkFlags:-VERBOSE=y});\n        fi;\n        _accumFlagsArray checkFlagsArray;\n        flagsArray+=(${checkTarget});\n        echoCmd 'check flags' \"${flagsArray[@]}\";\n        make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n        unset flagsArray;\n    fi;\n    runHook postCheck\n",
    "closeNest":" \n    true\n",
    "compressManPages":" \n    local dir=\"$1\";\n    if [ -L \"$dir\"/share ] || [ -L \"$dir\"/share/man ] || [ ! -d \"$dir/share/man\" ]; then\n        return;\n    fi;\n    echo \"gzipping man pages under $dir/share/man/\";\n    find \"$dir\"/share/man/ -type f -a '!' -regex '.*\\.\\(bz2\\|gz\\|xz\\)$' -print0 | while IFS= read -r -d '' f; do\n        if gzip -c -n \"$f\" > \"$f\".gz; then\n            rm \"$f\";\n        else\n            rm \"$f\".gz;\n        fi;\n    done;\n    find \"$dir\"/share/man/ -type l -a '!' -regex '.*\\.\\(bz2\\|gz\\|xz\\)$' -print0 | sort -z | while IFS= read -r -d '' f; do\n        local target;\n        target=\"$(readlink -f \"$f\")\";\n        if [ -f \"$target\".gz ]; then\n            ln -sf \"$target\".gz \"$f\".gz && rm \"$f\";\n        fi;\n    done\n",
    "configurePhase":" \n    runHook preConfigure;\n    : ${configureScript=};\n    if [[ -z \"$configureScript\" && -x ./configure ]]; then\n        configureScript=./configure;\n    fi;\n    if [ -z \"${dontFixLibtool:-}\" ]; then\n        export lt_cv_deplibs_check_method=\"${lt_cv_deplibs_check_method-pass_all}\";\n        local i;\n        find . -iname \"ltmain.sh\" -print0 | while IFS='' read -r -d '' i; do\n            echo \"fixing libtool script $i\";\n            fixLibtool \"$i\";\n        done;\n        CONFIGURE_MTIME_REFERENCE=$(mktemp configure.mtime.reference.XXXXXX);\n        find . -executable -type f -name configure -exec grep -l 'GNU Libtool is free software; you can redistribute it and/or modify' {} \\; -exec touch -r {} \"$CONFIGURE_MTIME_REFERENCE\" \\; -exec sed -i s_/usr/bin/file_file_g {} \\; -exec touch -r \"$CONFIGURE_MTIME_REFERENCE\" {} \\;;\n        rm -f \"$CONFIGURE_MTIME_REFERENCE\";\n    fi;\n    if [[ -z \"${dontAddPrefix:-}\" && -n \"$prefix\" ]]; then\n        prependToVar configureFlags \"${prefixKey:---prefix=}$prefix\";\n    fi;\n    if [[ -f \"$configureScript\" ]]; then\n        if [ -z \"${dontAddDisableDepTrack:-}\" ]; then\n            if grep -q dependency-tracking \"$configureScript\"; then\n                prependToVar configureFlags --disable-dependency-tracking;\n            fi;\n        fi;\n        if [ -z \"${dontDisableStatic:-}\" ]; then\n            if grep -q enable-static \"$configureScript\"; then\n                prependToVar configureFlags --disable-static;\n            fi;\n        fi;\n    fi;\n    if [ -n \"$configureScript\" ]; then\n        local -a flagsArray;\n        _accumFlagsArray configureFlags configureFlagsArray;\n        echoCmd 'configure flags' \"${flagsArray[@]}\";\n        $configureScript \"${flagsArray[@]}\";\n        unset flagsArray;\n    else\n        echo \"no configure script, doing nothing\";\n    fi;\n    runHook postConfigure\n",
    "consumeEntire":" \n    if IFS='' read -r -d '' $1; then\n        echo \"consumeEntire(): ERROR: Input null bytes, won't process\" 1>&2;\n        return 1;\n    fi\n",
    "distPhase":" \n    runHook preDist;\n    local flagsArray=();\n    _accumFlagsArray distFlags distFlagsArray;\n    flagsArray+=(${distTarget:-dist});\n    echo 'dist flags: %q' \"${flagsArray[@]}\";\n    make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n    if [ \"${dontCopyDist:-0}\" != 1 ]; then\n        mkdir -p \"$out/tarballs\";\n        cp -pvd ${tarballs[*]:-*.tar.gz} \"$out/tarballs\";\n    fi;\n    runHook postDist\n",
    "dumpVars":" \n    if [ \"${noDumpEnvVars:-0}\" != 1 ]; then\n        export 2> /dev/null >| \"$NIX_BUILD_TOP/env-vars\" || true;\n    fi\n",
    "echoCmd":" \n    printf \"%s:\" \"$1\";\n    shift;\n    printf ' %q' \"$@\";\n    echo\n",
    "exitHandler":" \n    exitCode=\"$?\";\n    set +e;\n    if [ -n \"${showBuildStats:-}\" ]; then\n        read -r -d '' -a buildTimes < <(times);\n        echo \"build times:\";\n        echo \"user time for the shell             ${buildTimes[0]}\";\n        echo \"system time for the shell           ${buildTimes[1]}\";\n        echo \"user time for all child processes   ${buildTimes[2]}\";\n        echo \"system time for all child processes ${buildTimes[3]}\";\n    fi;\n    if (( \"$exitCode\" != 0 )); then\n        runHook failureHook;\n        if [ -n \"${succeedOnFailure:-}\" ]; then\n            echo \"build failed with exit code $exitCode (ignored)\";\n            mkdir -p \"$out/nix-support\";\n            printf \"%s\" \"$exitCode\" > \"$out/nix-support/failed\";\n            exit 0;\n        fi;\n    else\n        runHook exitHook;\n    fi;\n    return \"$exitCode\"\n",
    "findInputs":" \n    local -r pkg=\"$1\";\n    local -r hostOffset=\"$2\";\n    local -r targetOffset=\"$3\";\n    (( hostOffset <= targetOffset )) || exit -1;\n    local varVar=\"${pkgAccumVarVars[hostOffset + 1]}\";\n    local varRef=\"$varVar[$((targetOffset - hostOffset))]\";\n    local var=\"${!varRef}\";\n    unset -v varVar varRef;\n    local varSlice=\"$var[*]\";\n    case \"${!varSlice-}\" in \n        *\" $pkg \"*)\n            return 0\n        ;;\n    esac;\n    unset -v varSlice;\n    eval \"$var\"'+=(\"$pkg\")';\n    if ! [ -e \"$pkg\" ]; then\n        echo \"build input $pkg does not exist\" 1>&2;\n        exit 1;\n    fi;\n    function mapOffset () \n    { \n        local -r inputOffset=\"$1\";\n        local -n outputOffset=\"$2\";\n        if (( inputOffset <= 0 )); then\n            outputOffset=$((inputOffset + hostOffset));\n        else\n            outputOffset=$((inputOffset - 1 + targetOffset));\n        fi\n    };\n    local relHostOffset;\n    for relHostOffset in \"${allPlatOffsets[@]}\";\n    do\n        local files=\"${propagatedDepFilesVars[relHostOffset + 1]}\";\n        local hostOffsetNext;\n        mapOffset \"$relHostOffset\" hostOffsetNext;\n        (( -1 <= hostOffsetNext && hostOffsetNext <= 1 )) || continue;\n        local relTargetOffset;\n        for relTargetOffset in \"${allPlatOffsets[@]}\";\n        do\n            (( \"$relHostOffset\" <= \"$relTargetOffset\" )) || continue;\n            local fileRef=\"${files}[$relTargetOffset - $relHostOffset]\";\n            local file=\"${!fileRef}\";\n            unset -v fileRef;\n            local targetOffsetNext;\n            mapOffset \"$relTargetOffset\" targetOffsetNext;\n            (( -1 <= hostOffsetNext && hostOffsetNext <= 1 )) || continue;\n            [[ -f \"$pkg/nix-support/$file\" ]] || continue;\n            local pkgNext;\n            read -r -d '' pkgNext < \"$pkg/nix-support/$file\" || true;\n            for pkgNext in $pkgNext;\n            do\n                findInputs \"$pkgNext\" \"$hostOffsetNext\" \"$targetOffsetNext\";\n            done;\n        done;\n    done\n",
    "fixLibtool":" \n    local search_path;\n    for flag in $NIX_LDFLAGS;\n    do\n        case $flag in \n            -L*)\n                search_path+=\" ${flag#-L}\"\n            ;;\n        esac;\n    done;\n    sed -i \"$1\" -e \"s^eval \\(sys_lib_search_path=\\).*^\\1'$search_path'^\" -e 's^eval sys_lib_.+search_path=.*^^'\n",
    "fixupPhase":" \n    local output;\n    for output in $(getAllOutputNames);\n    do\n        if [ -e \"${!output}\" ]; then\n            chmod -R u+w \"${!output}\";\n        fi;\n    done;\n    runHook preFixup;\n    local output;\n    for output in $(getAllOutputNames);\n    do\n        prefix=\"${!output}\" runHook fixupOutput;\n    done;\n    declare -ra flatVars=(depsBuildBuildPropagated propagatedNativeBuildInputs depsBuildTargetPropagated depsHostHostPropagated propagatedBuildInputs depsTargetTargetPropagated);\n    declare -ra flatFiles=(\"${propagatedBuildDepFiles[@]}\" \"${propagatedHostDepFiles[@]}\" \"${propagatedTargetDepFiles[@]}\");\n    local propagatedInputsIndex;\n    for propagatedInputsIndex in \"${!flatVars[@]}\";\n    do\n        local propagatedInputsSlice=\"${flatVars[$propagatedInputsIndex]}[@]\";\n        local propagatedInputsFile=\"${flatFiles[$propagatedInputsIndex]}\";\n        [[ -n \"${!propagatedInputsSlice}\" ]] || continue;\n        mkdir -p \"${!outputDev}/nix-support\";\n        printWords ${!propagatedInputsSlice} > \"${!outputDev}/nix-support/$propagatedInputsFile\";\n    done;\n    if [ -n \"${setupHook:-}\" ]; then\n        mkdir -p \"${!outputDev}/nix-support\";\n        substituteAll \"$setupHook\" \"${!outputDev}/nix-support/setup-hook\";\n    fi;\n    if [ -n \"${setupHooks:-}\" ]; then\n        mkdir -p \"${!outputDev}/nix-support\";\n        local hook;\n        for hook in ${setupHooks[@]};\n        do\n            local content;\n            consumeEntire content < \"$hook\";\n            substituteAllStream content \"file '$hook'\" >> \"${!outputDev}/nix-support/setup-hook\";\n            unset -v content;\n        done;\n        unset -v hook;\n    fi;\n    if [ -n \"${propagatedUserEnvPkgs:-}\" ]; then\n        mkdir -p \"${!outputBin}/nix-support\";\n        printWords $propagatedUserEnvPkgs > \"${!outputBin}/nix-support/propagated-user-env-packages\";\n    fi;\n    runHook postFixup\n",
    "genericBuild":" \n    if [ -f \"${buildCommandPath:-}\" ]; then\n        source \"$buildCommandPath\";\n        return;\n    fi;\n    if [ -n \"${buildCommand:-}\" ]; then\n        eval \"$buildCommand\";\n        return;\n    fi;\n    if [ -z \"${phases[*]:-}\" ]; then\n        phases=\"${prePhases[*]:-} unpackPhase patchPhase ${preConfigurePhases[*]:-}             configurePhase ${preBuildPhases[*]:-} buildPhase checkPhase             ${preInstallPhases[*]:-} installPhase ${preFixupPhases[*]:-} fixupPhase installCheckPhase             ${preDistPhases[*]:-} distPhase ${postPhases[*]:-}\";\n    fi;\n    for curPhase in ${phases[*]};\n    do\n        if [[ \"$curPhase\" = unpackPhase && -n \"${dontUnpack:-}\" ]]; then\n            continue;\n        fi;\n        if [[ \"$curPhase\" = patchPhase && -n \"${dontPatch:-}\" ]]; then\n            continue;\n        fi;\n        if [[ \"$curPhase\" = configurePhase && -n \"${dontConfigure:-}\" ]]; then\n            continue;\n        fi;\n        if [[ \"$curPhase\" = buildPhase && -n \"${dontBuild:-}\" ]]; then\n            continue;\n        fi;\n        if [[ \"$curPhase\" = checkPhase && -z \"${doCheck:-}\" ]]; then\n            continue;\n        fi;\n        if [[ \"$curPhase\" = installPhase && -n \"${dontInstall:-}\" ]]; then\n            continue;\n        fi;\n        if [[ \"$curPhase\" = fixupPhase && -n \"${dontFixup:-}\" ]]; then\n            continue;\n        fi;\n        if [[ \"$curPhase\" = installCheckPhase && -z \"${doInstallCheck:-}\" ]]; then\n            continue;\n        fi;\n        if [[ \"$curPhase\" = distPhase && -z \"${doDist:-}\" ]]; then\n            continue;\n        fi;\n        if [[ -n $NIX_LOG_FD ]]; then\n            echo \"@nix { \\\"action\\\": \\\"setPhase\\\", \\\"phase\\\": \\\"$curPhase\\\" }\" >&$NIX_LOG_FD;\n        fi;\n        showPhaseHeader \"$curPhase\";\n        dumpVars;\n        local startTime=$(date +\"%s\");\n        eval \"${!curPhase:-$curPhase}\";\n        local endTime=$(date +\"%s\");\n        showPhaseFooter \"$curPhase\" \"$startTime\" \"$endTime\";\n        if [ \"$curPhase\" = unpackPhase ]; then\n            [ -z \"${sourceRoot}\" ] || chmod +x \"${sourceRoot}\";\n            cd \"${sourceRoot:-.}\";\n        fi;\n    done\n",
    "getAllOutputNames":" \n    if [ -n \"$__structuredAttrs\" ]; then\n        echo \"${!outputs[*]}\";\n    else\n        echo \"$outputs\";\n    fi\n",
    "getHostRole":" \n    getRole \"$hostOffset\"\n",
    "getHostRoleEnvHook":" \n    getRole \"$depHostOffset\"\n",
    "getRole":" \n    case $1 in \n        -1)\n            role_post='_FOR_BUILD'\n        ;;\n        0)\n            role_post=''\n        ;;\n        1)\n            role_post='_FOR_TARGET'\n        ;;\n        *)\n            echo \"cctools-binutils-darwin-wrapper-973.0.1: used as improper sort of dependency\" 1>&2;\n            return 1\n        ;;\n    esac\n",
    "getTargetRole":" \n    getRole \"$targetOffset\"\n",
    "getTargetRoleEnvHook":" \n    getRole \"$depTargetOffset\"\n",
    "getTargetRoleWrapper":" \n    case $targetOffset in \n        -1)\n            export NIX_BINTOOLS_WRAPPER_TARGET_BUILD_aarch64_apple_darwin=1\n        ;;\n        0)\n            export NIX_BINTOOLS_WRAPPER_TARGET_HOST_aarch64_apple_darwin=1\n        ;;\n        1)\n            export NIX_BINTOOLS_WRAPPER_TARGET_TARGET_aarch64_apple_darwin=1\n        ;;\n        *)\n            echo \"cctools-binutils-darwin-wrapper-973.0.1: used as improper sort of dependency\" 1>&2;\n            return 1\n        ;;\n    esac\n",
    "header":" \n    echo \"$1\"\n",
    "installCheckPhase":" \n    runHook preInstallCheck;\n    if [[ -z \"${foundMakefile:-}\" ]]; then\n        echo \"no Makefile or custom installCheckPhase, doing nothing\";\n    else\n        if [[ -z \"${installCheckTarget:-}\" ]] && ! make -n ${makefile:+-f $makefile} ${installCheckTarget:-installcheck} > /dev/null 2>&1; then\n            echo \"no installcheck target in ${makefile:-Makefile}, doing nothing\";\n        else\n            local flagsArray=(${enableParallelChecking:+-j${NIX_BUILD_CORES}} SHELL=$SHELL);\n            _accumFlagsArray makeFlags makeFlagsArray installCheckFlags installCheckFlagsArray;\n            flagsArray+=(${installCheckTarget:-installcheck});\n            echoCmd 'installcheck flags' \"${flagsArray[@]}\";\n            make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n            unset flagsArray;\n        fi;\n    fi;\n    runHook postInstallCheck\n",
    "installPhase":" \n    runHook preInstall;\n    if [ -n \"$prefix\" ]; then\n        mkdir -p \"$prefix\";\n    fi;\n    local flagsArray=(SHELL=$SHELL);\n    _accumFlagsArray makeFlags makeFlagsArray installFlags installFlagsArray;\n    if [ -n \"$__structuredAttrs\" ]; then\n        flagsArray+=(\"${installTargets[@]:-install}\");\n    else\n        flagsArray+=(${installTargets:-install});\n    fi;\n    echoCmd 'install flags' \"${flagsArray[@]}\";\n    make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n    unset flagsArray;\n    runHook postInstall\n",
    "isELF":" \n    local fn=\"$1\";\n    local fd;\n    local magic;\n    exec {fd}< \"$fn\";\n    read -r -n 4 -u \"$fd\" magic;\n    exec {fd}>&-;\n    if [ \"$magic\" = 'ELF' ]; then\n        return 0;\n    else\n        return 1;\n    fi\n",
    "isMachO":" \n    local fn=\"$1\";\n    local fd;\n    local magic;\n    exec {fd}< \"$fn\";\n    read -r -n 4 -u \"$fd\" magic;\n    exec {fd}>&-;\n    if [[ \"$magic\" = $(echo -ne \"\\xfe\\xed\\xfa\\xcf\") || \"$magic\" = $(echo -ne \"\\xcf\\xfa\\xed\\xfe\") ]]; then\n        return 0;\n    else\n        if [[ \"$magic\" = $(echo -ne \"\\xfe\\xed\\xfa\\xce\") || \"$magic\" = $(echo -ne \"\\xce\\xfa\\xed\\xfe\") ]]; then\n            return 0;\n        else\n            if [[ \"$magic\" = $(echo -ne \"\\xca\\xfe\\xba\\xbe\") || \"$magic\" = $(echo -ne \"\\xbe\\xba\\xfe\\xca\") ]]; then\n                return 0;\n            else\n                return 1;\n            fi;\n        fi;\n    fi\n",
    "isScript":" \n    local fn=\"$1\";\n    local fd;\n    local magic;\n    exec {fd}< \"$fn\";\n    read -r -n 2 -u \"$fd\" magic;\n    exec {fd}>&-;\n    if [[ \"$magic\" =~ \\#! ]]; then\n        return 0;\n    else\n        return 1;\n    fi\n",
    "mapOffset":" \n    local -r inputOffset=\"$1\";\n    local -n outputOffset=\"$2\";\n    if (( inputOffset <= 0 )); then\n        outputOffset=$((inputOffset + hostOffset));\n    else\n        outputOffset=$((inputOffset - 1 + targetOffset));\n    fi\n",
    "moveToOutput":" \n    local patt=\"$1\";\n    local dstOut=\"$2\";\n    local output;\n    for output in $(getAllOutputNames);\n    do\n        if [ \"${!output}\" = \"$dstOut\" ]; then\n            continue;\n        fi;\n        local srcPath;\n        for srcPath in \"${!output}\"/$patt;\n        do\n            if [ ! -e \"$srcPath\" ] && [ ! -L \"$srcPath\" ]; then\n                continue;\n            fi;\n            if [ \"$dstOut\" = REMOVE ]; then\n                echo \"Removing $srcPath\";\n                rm -r \"$srcPath\";\n            else\n                local dstPath=\"$dstOut${srcPath#${!output}}\";\n                echo \"Moving $srcPath to $dstPath\";\n                if [ -d \"$dstPath\" ] && [ -d \"$srcPath\" ]; then\n                    rmdir \"$srcPath\" --ignore-fail-on-non-empty;\n                    if [ -d \"$srcPath\" ]; then\n                        mv -t \"$dstPath\" \"$srcPath\"/*;\n                        rmdir \"$srcPath\";\n                    fi;\n                else\n                    mkdir -p \"$(readlink -m \"$dstPath/..\")\";\n                    mv \"$srcPath\" \"$dstPath\";\n                fi;\n            fi;\n            local srcParent=\"$(readlink -m \"$srcPath/..\")\";\n            if rmdir \"$srcParent\"; then\n                echo \"Removing empty $srcParent/ and (possibly) its parents\";\n                rmdir -p --ignore-fail-on-non-empty \"$(readlink -m \"$srcParent/..\")\" 2> /dev/null || true;\n            fi;\n        done;\n    done\n",
    "patchPhase":" \n    runHook prePatch;\n    local -a patchesArray;\n    if [ -n \"$__structuredAttrs\" ]; then\n        patchesArray=(${patches:+\"${patches[@]}\"});\n    else\n        patchesArray=(${patches:-});\n    fi;\n    for i in \"${patchesArray[@]}\";\n    do\n        header \"applying patch $i\" 3;\n        local uncompress=cat;\n        case \"$i\" in \n            *.gz)\n                uncompress=\"gzip -d\"\n            ;;\n            *.bz2)\n                uncompress=\"bzip2 -d\"\n            ;;\n            *.xz)\n                uncompress=\"xz -d\"\n            ;;\n            *.lzma)\n                uncompress=\"lzma -d\"\n            ;;\n        esac;\n        local -a flagsArray;\n        if [ -n \"$__structuredAttrs\" ]; then\n            flagsArray=(\"${patchFlags[@]:--p1}\");\n        else\n            flagsArray=(${patchFlags:--p1});\n        fi;\n        $uncompress < \"$i\" 2>&1 | patch \"${flagsArray[@]}\";\n    done;\n    runHook postPatch\n",
    "patchShebangs":" \n    local pathName;\n    if [[ \"$1\" == \"--host\" ]]; then\n        pathName=HOST_PATH;\n        shift;\n    else\n        if [[ \"$1\" == \"--build\" ]]; then\n            pathName=PATH;\n            shift;\n        fi;\n    fi;\n    echo \"patching script interpreter paths in $@\";\n    local f;\n    local oldPath;\n    local newPath;\n    local arg0;\n    local args;\n    local oldInterpreterLine;\n    local newInterpreterLine;\n    if [[ $# -eq 0 ]]; then\n        echo \"No arguments supplied to patchShebangs\" 1>&2;\n        return 0;\n    fi;\n    local f;\n    while IFS= read -r -d '' f; do\n        isScript \"$f\" || continue;\n        read -r oldInterpreterLine < \"$f\";\n        read -r oldPath arg0 args <<< \"${oldInterpreterLine:2}\";\n        if [[ -z \"$pathName\" ]]; then\n            if [[ -n $strictDeps && $f == \"$NIX_STORE\"* ]]; then\n                pathName=HOST_PATH;\n            else\n                pathName=PATH;\n            fi;\n        fi;\n        if [[ \"$oldPath\" == *\"/bin/env\" ]]; then\n            if [[ $arg0 == \"-\"* || $arg0 == *\"=\"* ]]; then\n                echo \"$f: unsupported interpreter directive \\\"$oldInterpreterLine\\\" (set dontPatchShebangs=1 and handle shebang patching yourself)\" 1>&2;\n                exit 1;\n            fi;\n            newPath=\"$(PATH=\"${!pathName}\" command -v \"$arg0\" || true)\";\n        else\n            if [[ -z $oldPath ]]; then\n                oldPath=\"/bin/sh\";\n            fi;\n            newPath=\"$(PATH=\"${!pathName}\" command -v \"$(basename \"$oldPath\")\" || true)\";\n            args=\"$arg0 $args\";\n        fi;\n        newInterpreterLine=\"$newPath $args\";\n        newInterpreterLine=${newInterpreterLine%${newInterpreterLine##*[![:space:]]}};\n        if [[ -n \"$oldPath\" && \"${oldPath:0:${#NIX_STORE}}\" != \"$NIX_STORE\" ]]; then\n            if [[ -n \"$newPath\" && \"$newPath\" != \"$oldPath\" ]]; then\n                echo \"$f: interpreter directive changed from \\\"$oldInterpreterLine\\\" to \\\"$newInterpreterLine\\\"\";\n                escapedInterpreterLine=${newInterpreterLine//\\\\/\\\\\\\\};\n                timestamp=$(stat --printf \"%y\" \"$f\");\n                sed -i -e \"1 s|.*|#\\!$escapedInterpreterLine|\" \"$f\";\n                touch --date \"$timestamp\" \"$f\";\n            fi;\n        fi;\n    done < <(find \"$@\" -type f -perm -0100 -print0);\n    stopNest\n",
    "patchShebangsAuto":" \n    if [[ -z \"${dontPatchShebangs-}\" && -e \"$prefix\" ]]; then\n        if [[ \"$output\" != out && \"$output\" = \"$outputDev\" ]]; then\n            patchShebangs --build \"$prefix\";\n        else\n            patchShebangs --host \"$prefix\";\n        fi;\n    fi\n",
    "prependToVar":" \n    local -n nameref=\"$1\";\n    useArray=;\n    if [ -n \"$__structuredAttrs\" ]; then\n        useArray=true;\n    else\n        useArray=false;\n    fi;\n    if declare -p \"$1\" 2> /dev/null | grep -q '^'; then\n        type=\"$(declare -p \"$1\")\";\n        if [[ \"$type\" =~ \"declare -A\" ]]; then\n            echo \"prependToVar(): ERROR: trying to use prependToVar on an associative array.\" 1>&2;\n            return 1;\n        else\n            if [[ \"$type\" =~ \"declare -a\" ]]; then\n                useArray=true;\n            else\n                useArray=false;\n            fi;\n        fi;\n    fi;\n    shift;\n    if $useArray; then\n        nameref=(\"$@\" ${nameref+\"${nameref[@]}\"});\n    else\n        nameref=\"$* ${nameref-}\";\n    fi\n",
    "printLines":" \n    (( \"$#\" > 0 )) || return 0;\n    printf '%s\\n' \"$@\"\n",
    "printWords":" \n    (( \"$#\" > 0 )) || return 0;\n    printf '%s ' \"$@\"\n",
    "runHook":" \n    local hookName=\"$1\";\n    shift;\n    local hooksSlice=\"${hookName%Hook}Hooks[@]\";\n    local hook;\n    for hook in \"_callImplicitHook 0 $hookName\" ${!hooksSlice+\"${!hooksSlice}\"};\n    do\n        _eval \"$hook\" \"$@\";\n    done;\n    return 0\n",
    "runOneHook":" \n    local hookName=\"$1\";\n    shift;\n    local hooksSlice=\"${hookName%Hook}Hooks[@]\";\n    local hook ret=1;\n    for hook in \"_callImplicitHook 1 $hookName\" ${!hooksSlice+\"${!hooksSlice}\"};\n    do\n        if _eval \"$hook\" \"$@\"; then\n            ret=0;\n            break;\n        fi;\n    done;\n    return \"$ret\"\n",
    "showPhaseFooter":" \n    local phase=\"$1\";\n    local startTime=\"$2\";\n    local endTime=\"$3\";\n    local delta=$(( endTime - startTime ));\n    (( $delta < 30 )) && return;\n    local H=$((delta/3600));\n    local M=$((delta%3600/60));\n    local S=$((delta%60));\n    echo -n \"$phase completed in \";\n    (( $H > 0 )) && echo -n \"$H hours \";\n    (( $M > 0 )) && echo -n \"$M minutes \";\n    echo \"$S seconds\"\n",
    "showPhaseHeader":" \n    local phase=\"$1\";\n    case \"$phase\" in \n        unpackPhase)\n            header \"unpacking sources\"\n        ;;\n        patchPhase)\n            header \"patching sources\"\n        ;;\n        configurePhase)\n            header \"configuring\"\n        ;;\n        buildPhase)\n            header \"building\"\n        ;;\n        checkPhase)\n            header \"running tests\"\n        ;;\n        installPhase)\n            header \"installing\"\n        ;;\n        fixupPhase)\n            header \"post-installation fixup\"\n        ;;\n        installCheckPhase)\n            header \"running install tests\"\n        ;;\n        *)\n            header \"$phase\"\n        ;;\n    esac\n",
    "stopNest":" \n    true\n",
    "stripDirs":" \n    local cmd=\"$1\";\n    local ranlibCmd=\"$2\";\n    local paths=\"$3\";\n    local stripFlags=\"$4\";\n    local pathsNew=;\n    local p;\n    for p in ${paths};\n    do\n        if [ -e \"$prefix/$p\" ]; then\n            pathsNew=\"${pathsNew} $prefix/$p\";\n        fi;\n    done;\n    paths=${pathsNew};\n    if [ -n \"${paths}\" ]; then\n        echo \"stripping (with command $cmd and flags $stripFlags) in $paths\";\n        find $paths -type f -a '!' -wholename \"$prefix/lib/debug/*\" -exec $cmd $stripFlags '{}' \\; 2> /dev/null;\n        find $paths -name '*.a' -type f -exec $ranlibCmd '{}' \\; 2> /dev/null;\n    fi\n",
    "stripHash":" \n    local strippedName casematchOpt=0;\n    strippedName=\"$(basename -- \"$1\")\";\n    shopt -q nocasematch && casematchOpt=1;\n    shopt -u nocasematch;\n    if [[ \"$strippedName\" =~ ^[a-z0-9]{32}- ]]; then\n        echo \"${strippedName:33}\";\n    else\n        echo \"$strippedName\";\n    fi;\n    if (( casematchOpt )); then\n        shopt -s nocasematch;\n    fi\n",
    "substitute":" \n    local input=\"$1\";\n    local output=\"$2\";\n    shift 2;\n    if [ ! -f \"$input\" ]; then\n        echo \"substitute(): ERROR: file '$input' does not exist\" 1>&2;\n        return 1;\n    fi;\n    local content;\n    consumeEntire content < \"$input\";\n    if [ -e \"$output\" ]; then\n        chmod +w \"$output\";\n    fi;\n    substituteStream content \"file '$input'\" \"$@\" > \"$output\"\n",
    "substituteAll":" \n    local input=\"$1\";\n    local output=\"$2\";\n    local -a args=();\n    _allFlags;\n    substitute \"$input\" \"$output\" \"${args[@]}\"\n",
    "substituteAllInPlace":" \n    local fileName=\"$1\";\n    shift;\n    substituteAll \"$fileName\" \"$fileName\" \"$@\"\n",
    "substituteAllStream":" \n    local -a args=();\n    _allFlags;\n    substituteStream \"$1\" \"$2\" \"${args[@]}\"\n",
    "substituteInPlace":" \n    local -a fileNames=();\n    for arg in \"$@\";\n    do\n        if [[ \"$arg\" = \"--\"* ]]; then\n            break;\n        fi;\n        fileNames+=(\"$arg\");\n        shift;\n    done;\n    for file in \"${fileNames[@]}\";\n    do\n        substitute \"$file\" \"$file\" \"$@\";\n    done\n",
    "substituteStream":" \n    local var=$1;\n    local description=$2;\n    shift 2;\n    while (( \"$#\" )); do\n        case \"$1\" in \n            --replace)\n                pattern=\"$2\";\n                replacement=\"$3\";\n                shift 3;\n                local savedvar;\n                savedvar=\"${!var}\";\n                eval \"$var\"'=${'\"$var\"'//\"$pattern\"/\"$replacement\"}';\n                if [ \"$pattern\" != \"$replacement\" ]; then\n                    if [ \"${!var}\" == \"$savedvar\" ]; then\n                        echo \"substituteStream(): WARNING: pattern '$pattern' doesn't match anything in $description\" 1>&2;\n                    fi;\n                fi\n            ;;\n            --subst-var)\n                local varName=\"$2\";\n                shift 2;\n                if ! [[ \"$varName\" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then\n                    echo \"substituteStream(): ERROR: substitution variables must be valid Bash names, \\\"$varName\\\" isn't.\" 1>&2;\n                    return 1;\n                fi;\n                if [ -z ${!varName+x} ]; then\n                    echo \"substituteStream(): ERROR: variable \\$$varName is unset\" 1>&2;\n                    return 1;\n                fi;\n                pattern=\"@$varName@\";\n                replacement=\"${!varName}\";\n                eval \"$var\"'=${'\"$var\"'//\"$pattern\"/\"$replacement\"}'\n            ;;\n            --subst-var-by)\n                pattern=\"@$2@\";\n                replacement=\"$3\";\n                eval \"$var\"'=${'\"$var\"'//\"$pattern\"/\"$replacement\"}';\n                shift 3\n            ;;\n            *)\n                echo \"substituteStream(): ERROR: Invalid command line argument: $1\" 1>&2;\n                return 1\n            ;;\n        esac;\n    done;\n    printf \"%s\" \"${!var}\"\n",
    "unpackFile":" \n    curSrc=\"$1\";\n    header \"unpacking source archive $curSrc\" 3;\n    if ! runOneHook unpackCmd \"$curSrc\"; then\n        echo \"do not know how to unpack source archive $curSrc\";\n        exit 1;\n    fi\n",
    "unpackPhase":" \n    runHook preUnpack;\n    if [ -z \"${srcs:-}\" ]; then\n        if [ -z \"${src:-}\" ]; then\n            echo 'variable $src or $srcs should point to the source';\n            exit 1;\n        fi;\n        srcs=\"$src\";\n    fi;\n    local -a srcsArray;\n    if [ -n \"$__structuredAttrs\" ]; then\n        srcsArray=(\"${srcs[@]}\");\n    else\n        srcsArray=($srcs);\n    fi;\n    local dirsBefore=\"\";\n    for i in *;\n    do\n        if [ -d \"$i\" ]; then\n            dirsBefore=\"$dirsBefore $i \";\n        fi;\n    done;\n    for i in \"${srcsArray[@]}\";\n    do\n        unpackFile \"$i\";\n    done;\n    : ${sourceRoot=};\n    if [ -n \"${setSourceRoot:-}\" ]; then\n        runOneHook setSourceRoot;\n    else\n        if [ -z \"$sourceRoot\" ]; then\n            for i in *;\n            do\n                if [ -d \"$i\" ]; then\n                    case $dirsBefore in \n                        *\\ $i\\ *)\n\n                        ;;\n                        *)\n                            if [ -n \"$sourceRoot\" ]; then\n                                echo \"unpacker produced multiple directories\";\n                                exit 1;\n                            fi;\n                            sourceRoot=\"$i\"\n                        ;;\n                    esac;\n                fi;\n            done;\n        fi;\n    fi;\n    if [ -z \"$sourceRoot\" ]; then\n        echo \"unpacker appears to have produced no directories\";\n        exit 1;\n    fi;\n    echo \"source root is $sourceRoot\";\n    if [ \"${dontMakeSourcesWritable:-0}\" != 1 ]; then\n        chmod -R u+w -- \"$sourceRoot\";\n    fi;\n    runHook postUnpack\n",
    "updateAutotoolsGnuConfigScriptsPhase":" \n    if [ -n \"${dontUpdateAutotoolsGnuConfigScripts-}\" ]; then\n        return;\n    fi;\n    for script in config.sub config.guess;\n    do\n        for f in $(find . -type f -name \"$script\");\n        do\n            echo \"Updating Autotools / GNU config script to a newer upstream version: $f\";\n            cp -f \"/nix/store/s38wd1ckjzszdr1iqgqps2698mj9y9xw-gnu-config-2021-01-25/$script\" \"$f\";\n        done;\n    done\n",
    "updateSourceDateEpoch":" \n    local path=\"$1\";\n    local -a res=($(find \"$path\" -type f -not -newer \"$NIX_BUILD_TOP/..\" -printf '%T@ %p\\0' | sort -n --zero-terminated | tail -n1 --zero-terminated | head -c -1));\n    local time=\"${res[0]//\\.[0-9]*/}\";\n    local newestFile=\"${res[1]}\";\n    if [ \"${time:-0}\" -gt \"$SOURCE_DATE_EPOCH\" ]; then\n        echo \"setting SOURCE_DATE_EPOCH to timestamp $time of file $newestFile\";\n        export SOURCE_DATE_EPOCH=\"$time\";\n        local now=\"$(date +%s)\";\n        if [ \"$time\" -gt $((now - 60)) ]; then\n            echo \"warning: file $newestFile may be generated; SOURCE_DATE_EPOCH may be non-deterministic\";\n        fi;\n    fi\n"
  },
  "variables": {
    "AR": {"type": "exported", "value": "ar"},
    "AS": {"type": "exported", "value": "as"},
    "BASH": {"type": "var", "value": "/nix/store/n0k8njvgg6yjapkl81rm821s9vx0qrwb-bash-5.2-p15/bin/bash"},
    "BASHOPTS": {"type": "unknown"},
    "BASHPID": {"type": "unknown"},
    "CC": {"type": "exported", "value": "clang"},
    "CONFIG_SHELL": {"type": "exported", "value": "/nix/store/n0k8njvgg6yjapkl81rm821s9vx0qrwb-bash-5.2-p15/bin/bash"},
    "CXX": {"type": "exported", "value": "clang++"},
    "EPOCHREALTIME": {"type": "var", "value": "1674677964.365968"},
    "EPOCHSECONDS": {"type": "var", "value": "1674677964"},
    "HOME": {"type": "exported", "value": "/homeless-shelter"},
    "HOSTTYPE": {"type": "var", "value": "aarch64"},
    "HOST_PATH": {"type": "exported", "value": "/nix/store/r01krwydyya0zkdc68qwp8j2i5lym0aq-nodejs-18.13.0/bin:/nix/store/1zz60imv11dwbx3gk86cbkw825r4qc1g-yarn-1.22.19/bin:/nix/store/5m5ibgyi5fl248wjh3rvclh636mrw87w-jq-1.6-bin/bin:/nix/store/gvl9w6c5q83nd4svz5v5hqhgfzlcpl3y-coreutils-9.1/bin:/nix/store/x080znwmkginz9xb1qchm5dd188m59hg-findutils-4.9.0/bin:/nix/store/pnp0lkyjhrhl7vj0fgrpx80zzzmnkqi6-diffutils-3.8/bin:/nix/store/vjnvxrpi26aigy96fvcfwjx5y5j18h7r-gnused-4.9/bin:/nix/store/8j799mid9ai29hg4s4xifx3yn1x1qply-gnugrep-3.7/bin:/nix/store/40sbwcrzl80vrlz9wwdml69b6y224kbs-gawk-5.2.1/bin:/nix/store/wmybxxsdc4h640xgzijmqi1yic3fvs6x-gnutar-1.34/bin:/nix/store/3x74r0m2833bqr7krjf4q8q2wpb5l3v7-gzip-1.12/bin:/nix/store/8wdl82qvvd6hkq361vq8cmi110g3pbvg-bzip2-1.0.8-bin/bin:/nix/store/6lkc7zwfkr21si1g85mq39mmlpf6mn35-gnumake-4.4/bin:/nix/store/n0k8njvgg6yjapkl81rm821s9vx0qrwb-bash-5.2-p15/bin:/nix/store/m5dhzr6yzq199ahyiv3xqpiy4japhr9f-patch-2.7.6/bin:/nix/store/dd4776lwwki6dxrjn2cli3sc9mwmdxp5-xz-5.4.0-bin/bin:/nix/store/4zhg5g546pa5gprszifqz1lx9vg8h8nv-file-5.43/bin"},
    "IFS": {"type": "var", "value": " \t\n"},
    "IN_NIX_SHELL": {"type": "exported", "value": "impure"},
    "LD": {"type": "exported", "value": "ld"},
    "LD_DYLD_PATH": {"type": "exported", "value": "/usr/lib/dyld"},
    "LINENO": {"type": "var", "value": "73"},
    "MACHTYPE": {"type": "var", "value": "aarch64-apple-darwin22.2.0"},
    "MACOSX_DEPLOYMENT_TARGET": {"type": "exported", "value": "11.0"},
    "NIX_BINTOOLS": {"type": "exported", "value": "/nix/store/xh503dqb1yb5w9mjziclp81gi4cqmwf6-cctools-binutils-darwin-wrapper-973.0.1"},
    "NIX_BINTOOLS_WRAPPER_TARGET_HOST_aarch64_apple_darwin": {"type": "exported", "value": "1"},
    "NIX_BUILD_CORES": {"type": "exported", "value": "8"},
    "NIX_BUILD_TOP": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "NIX_CC": {"type": "exported", "value": "/nix/store/bwscr98440mhhlg556fqhp5ll2fxnfic-clang-wrapper-11.1.0"},
    "NIX_CC_WRAPPER_TARGET_HOST_aarch64_apple_darwin": {"type": "exported", "value": "1"},
    "NIX_CFLAGS_COMPILE": {"type": "exported", "value": " -frandom-seed=3kkifha15m -isystem /nix/store/5sby1xhsk6dzi83lsfrxp3w2hz32r3j7-libcxx-11.1.0-dev/include -isystem /nix/store/29095kfx46cjahphxf51w5mz5y38m7ap-libcxxabi-11.1.0-dev/include -isystem /nix/store/r01krwydyya0zkdc68qwp8j2i5lym0aq-nodejs-18.13.0/include -isystem /nix/store/02l1dpfsjjsym5y9kllgxgs4c3jgcxgl-jq-1.6-dev/include -iframework /nix/store/wzfrrcy9bawjvmz7wm4ms7mcymxw81bg-apple-framework-CoreFoundation-11.0.0/Library/Frameworks -isystem /nix/store/k1r23ygby2l7g7vz4na10c928873pgva-libobjc-11.0.0/include -isystem /nix/store/5sby1xhsk6dzi83lsfrxp3w2hz32r3j7-libcxx-11.1.0-dev/include -isystem /nix/store/29095kfx46cjahphxf51w5mz5y38m7ap-libcxxabi-11.1.0-dev/include -isystem /nix/store/r01krwydyya0zkdc68qwp8j2i5lym0aq-nodejs-18.13.0/include -isystem /nix/store/02l1dpfsjjsym5y9kllgxgs4c3jgcxgl-jq-1.6-dev/include -iframework /nix/store/wzfrrcy9bawjvmz7wm4ms7mcymxw81bg-apple-framework-CoreFoundation-11.0.0/Library/Frameworks -isystem /nix/store/k1r23ygby2l7g7vz4na10c928873pgva-libobjc-11.0.0/include"},
    "NIX_COREFOUNDATION_RPATH": {"type": "exported", "value": "/nix/store/wzfrrcy9bawjvmz7wm4ms7mcymxw81bg-apple-framework-CoreFoundation-11.0.0/Library/Frameworks"},
    "NIX_DONT_SET_RPATH": {"type": "exported", "value": "1"},
    "NIX_DONT_SET_RPATH_FOR_BUILD": {"type": "exported", "value": "1"},
    "NIX_ENFORCE_NO_NATIVE": {"type": "exported", "value": "1"},
    "NIX_ENFORCE_PURITY": {"type": "exported", "value": "1"},
    "NIX_HARDENING_ENABLE": {"type": "exported", "value": "fortify stackprotector pic strictoverflow format relro bindnow"},
    "NIX_IGNORE_LD_THROUGH_GCC": {"type": "exported", "value": "1"},
    "NIX_INDENT_MAKE": {"type": "exported", "value": "1"},
    "NIX_LDFLAGS": {"type": "exported", "value": " -L/nix/store/qz1rmnp4y95qr0ikz0v0xr87fbwrvv74-libcxx-11.1.0/lib -L/nix/store/6351z3343l2s5i8599p29ypz1i2hb8xc-libcxxabi-11.1.0/lib -L/nix/store/l739pwvg27xp2gg8jncx1yzrhxy03my6-compiler-rt-libc-11.1.0/lib -L/nix/store/q31jcs8ri7a176nhj6jq2jnn9br9fgay-jq-1.6-lib/lib -L/nix/store/k1r23ygby2l7g7vz4na10c928873pgva-libobjc-11.0.0/lib -L/nix/store/qz1rmnp4y95qr0ikz0v0xr87fbwrvv74-libcxx-11.1.0/lib -L/nix/store/6351z3343l2s5i8599p29ypz1i2hb8xc-libcxxabi-11.1.0/lib -L/nix/store/l739pwvg27xp2gg8jncx1yzrhxy03my6-compiler-rt-libc-11.1.0/lib -L/nix/store/q31jcs8ri7a176nhj6jq2jnn9br9fgay-jq-1.6-lib/lib -L/nix/store/k1r23ygby2l7g7vz4na10c928873pgva-libobjc-11.0.0/lib"},
    "NIX_LOG_FD": {"type": "exported", "value": "2"},
    "NIX_NO_SELF_RPATH": {"type": "exported", "value": "1"},
    "NIX_STORE": {"type": "exported", "value": "/nix/store"},
    "NM": {"type": "exported", "value": "nm"},
    "NODE_PATH": {"type": "exported", "value": "/nix/store/r01krwydyya0zkdc68qwp8j2i5lym0aq-nodejs-18.13.0/lib/node_modules"},
    "OLDPWD": {"type": "exported", "value": ""},
    "OPTERR": {"type": "var", "value": "1"},
    "OPTIND": {"type": "unknown"},
    "OSTYPE": {"type": "var", "value": "darwin22.2.0"},
    "PATH": {"type": "exported", "value": "/nix/store/bwscr98440mhhlg556fqhp5ll2fxnfic-clang-wrapper-11.1.0/bin:/nix/store/ssfpjhrysqf6ywz5sqi8gpz28zc23kiy-clang-11.1.0/bin:/nix/store/gvl9w6c5q83nd4svz5v5hqhgfzlcpl3y-coreutils-9.1/bin:/nix/store/xh503dqb1yb5w9mjziclp81gi4cqmwf6-cctools-binutils-darwin-wrapper-973.0.1/bin:/nix/store/a17dwfwqj5ry734zfv3k1f5n37s4wxns-cctools-binutils-darwin-973.0.1/bin:/nix/store/r01krwydyya0zkdc68qwp8j2i5lym0aq-nodejs-18.13.0/bin:/nix/store/1zz60imv11dwbx3gk86cbkw825r4qc1g-yarn-1.22.19/bin:/nix/store/5m5ibgyi5fl248wjh3rvclh636mrw87w-jq-1.6-bin/bin:/nix/store/gvl9w6c5q83nd4svz5v5hqhgfzlcpl3y-coreutils-9.1/bin:/nix/store/x080znwmkginz9xb1qchm5dd188m59hg-findutils-4.9.0/bin:/nix/store/pnp0lkyjhrhl7vj0fgrpx80zzzmnkqi6-diffutils-3.8/bin:/nix/store/vjnvxrpi26aigy96fvcfwjx5y5j18h7r-gnused-4.9/bin:/nix/store/8j799mid9ai29hg4s4xifx3yn1x1qply-gnugrep-3.7/bin:/nix/store/40sbwcrzl80vrlz9wwdml69b6y224kbs-gawk-5.2.1/bin:/nix/store/wmybxxsdc4h640xgzijmqi1yic3fvs6x-gnutar-1.34/bin:/nix/store/3x74r0m2833bqr7krjf4q8q2wpb5l3v7-gzip-1.12/bin:/nix/store/8wdl82qvvd6hkq361vq8cmi110g3pbvg-bzip2-1.0.8-bin/bin:/nix/store/6lkc7zwfkr21si1g85mq39mmlpf6mn35-gnumake-4.4/bin:/nix/store/n0k8njvgg6yjapkl81rm821s9vx0qrwb-bash-5.2-p15/bin:/nix/store/m5dhzr6yzq199ahyiv3xqpiy4japhr9f-patch-2.7.6/bin:/nix/store/dd4776lwwki6dxrjn2cli3sc9mwmdxp5-xz-5.4.0-bin/bin:/nix/store/4zhg5g546pa5gprszifqz1lx9vg8h8nv-file-5.43/bin"},
    "PATH_LOCALE": {"type": "exported", "value": "/nix/store/mwxvn44vbhpc4mkn1djq1nfqrzhp3nbk-adv_cmds-119-locale/share/locale"},
    "PS4": {"type": "var", "value": "+ "},
    "RANLIB": {"type": "exported", "value": "ranlib"},
    "SHELL": {"type": "exported", "value": "/nix/store/n0k8njvgg6yjapkl81rm821s9vx0qrwb-bash-5.2-p15/bin/bash"},
    "SHELLOPTS": {"type": "unknown"},
    "SIZE": {"type": "exported", "value": "size"},
    "SOURCE_DATE_EPOCH": {"type": "exported", "value": "315532800"},
    "SRANDOM": {"type": "unknown"},
    "STRINGS": {"type": "exported", "value": "strings"},
    "STRIP": {"type": "exported", "value": "strip"},
    "TEMP": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "TEMPDIR": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "TERM": {"type": "exported", "value": "xterm-256color"},
    "TMP": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "TMPDIR": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "TZ": {"type": "exported", "value": "UTC"},
    "XDG_DATA_DIRS": {"type": "exported", "value": ""},
    "__darwinAllowLocalNetworking": {"type": "exported", "value": ""},
    "__impureHostDeps": {"type": "exported", "value": "/bin/sh /usr/lib/libSystem.B.dylib /usr/lib/system/libunc.dylib /dev/zero /dev/random /dev/urandom /bin/sh"},
    "__propagatedImpureHostDeps": {"type": "exported", "value": ""},
    "__propagatedSandboxProfile": {"type": "exported", "value": ""},
    "__sandboxProfile": {"type": "exported", "value": ""},
    "__structuredAttrs": {"type": "exported", "value": ""},
    "buildInputs": {"type": "exported", "value": "/nix/store/r01krwydyya0zkdc68qwp8j2i5lym0aq-nodejs-18.13.0 /nix/store/1zz60imv11dwbx3gk86cbkw825r4qc1g-yarn-1.22.19 /nix/store/02l1dpfsjjsym5y9kllgxgs4c3jgcxgl-jq-1.6-dev"},
    "buildPhase": {"type": "exported", "value": "{ echo \"------------------------------------------------------------\";\n  echo \" WARNING: the existence of this path is not guaranteed.\";\n  echo \" It is an internal implementation detail for pkgs.mkShell.\";\n  echo \"------------------------------------------------------------\";\n  echo;\n  # Record all build inputs as runtime dependencies\n  export;\n} >> \"$out\"\n"},
    "builder": {"type": "exported", "value": "/nix/store/n0k8njvgg6yjapkl81rm821s9vx0qrwb-bash-5.2-p15/bin/bash"},
    "cmakeFlags": {"type": "exported", "value": ""},
    "configureFlags": {"type": "exported", "value": ""},
    "defaultBuildInputs": {"type": "var", "value": "/nix/store/wzfrrcy9bawjvmz7wm4ms7mcymxw81bg-apple-framework-CoreFoundation-11.0.0"},
    "defaultNativeBuildInputs": {"type": "var", "value": "/nix/store/pnjndfczs1ggn962aalsdf5kxwqlsajg-hook /nix/store/g0bmb8iq70gf1yk6pr50i2bp7gxfz77i-audit-tmpdir.sh /nix/store/m54bmrhj6fqz8nds5zcj97w9s9bckc9v-compress-man-pages.sh /nix/store/skk3q7jzy3yw80mdsq2lv0l4sr796xi2-make-symlinks-relative.sh /nix/store/5yzw0vhkyszf2d179m0qfkgxmp5wjjx4-move-docs.sh /nix/store/fyaryjvghbkpfnsyw97hb3lyb37s1pd6-move-lib64.sh /nix/store/kd4xwxjpjxi71jkm6ka0np72if9rm3y0-move-sbin.sh /nix/store/pag6l61paj1dc9sv15l7bm5c17xn5kyk-move-systemd-user-units.sh /nix/store/yf7nb1zp58jvdl4zw8jkcpwpmq3yxpjz-multiple-outputs.sh /nix/store/bnj8d7mvbkg3vdb07yz74yhl3g107qq5-patch-shebangs.sh /nix/store/cickvswrvann041nqxb0rxilc46svw1n-prune-libtool-files.sh /nix/store/wlwcf1nw2b21m4gghj70hbg1v7x53ld8-reproducible-builds.sh /nix/store/ngg1cv31c8c7bcm2n8ww4g06nq7s4zhm-set-source-date-epoch-to-latest.sh /nix/store/fmsdxxw5kg6s73hymvynw4jyxknkzqcp-strip.sh /nix/store/bwscr98440mhhlg556fqhp5ll2fxnfic-clang-wrapper-11.1.0"},
    "depsBuildBuild": {"type": "exported", "value": ""},
    "depsBuildBuildPropagated": {"type": "exported", "value": ""},
    "depsBuildTarget": {"type": "exported", "value": ""},
    "depsBuildTargetPropagated": {"type": "exported", "value": ""},
    "depsHostHost": {"type": "exported", "value": ""},
    "depsHostHostPropagated": {"type": "exported", "value": ""},
    "depsTargetTarget": {"type": "exported", "value": ""},
    "depsTargetTargetPropagated": {"type": "exported", "value": ""},
    "doCheck": {"type": "exported", "value": ""},
    "doInstallCheck": {"type": "exported", "value": ""},
    "dontAddDisableDepTrack": {"type": "exported", "value": "1"},
    "envBuildBuildHooks": {"type": "array", "value": []},
    "envBuildHostHooks": {"type": "array", "value": []},
    "envBuildTargetHooks": {"type": "array", "value": []},
    "envHostHostHooks": {"type": "array", "value": ["ccWrapper_addCVars" , "bintoolsWrapper_addLDVars" , "addNodePath" ]},
    "envHostTargetHooks": {"type": "array", "value": ["ccWrapper_addCVars" , "bintoolsWrapper_addLDVars" , "addNodePath" ]},
    "envTargetTargetHooks": {"type": "array", "value": []},
    "fixupOutputHooks": {"type": "array", "value": ["if [[ -z \"${noAuditTmpdir-}\" && -e \"$prefix\" ]]; then auditTmpdir \"$prefix\"; fi" , "if [ -z \"${dontGzipMan-}\" ]; then compressManPages \"$prefix\"; fi" , "_moveLib64" , "_moveSbin" , "_moveSystemdUserUnits" , "patchShebangsAuto" , "_pruneLibtoolFiles" , "_doStrip" ]},
    "initialPath": {"type": "var", "value": "/nix/store/gvl9w6c5q83nd4svz5v5hqhgfzlcpl3y-coreutils-9.1 /nix/store/x080znwmkginz9xb1qchm5dd188m59hg-findutils-4.9.0 /nix/store/pnp0lkyjhrhl7vj0fgrpx80zzzmnkqi6-diffutils-3.8 /nix/store/vjnvxrpi26aigy96fvcfwjx5y5j18h7r-gnused-4.9 /nix/store/8j799mid9ai29hg4s4xifx3yn1x1qply-gnugrep-3.7 /nix/store/40sbwcrzl80vrlz9wwdml69b6y224kbs-gawk-5.2.1 /nix/store/wmybxxsdc4h640xgzijmqi1yic3fvs6x-gnutar-1.34 /nix/store/3x74r0m2833bqr7krjf4q8q2wpb5l3v7-gzip-1.12 /nix/store/8wdl82qvvd6hkq361vq8cmi110g3pbvg-bzip2-1.0.8-bin /nix/store/6lkc7zwfkr21si1g85mq39mmlpf6mn35-gnumake-4.4 /nix/store/n0k8njvgg6yjapkl81rm821s9vx0qrwb-bash-5.2-p15 /nix/store/m5dhzr6yzq199ahyiv3xqpiy4japhr9f-patch-2.7.6 /nix/store/dd4776lwwki6dxrjn2cli3sc9mwmdxp5-xz-5.4.0-bin /nix/store/4zhg5g546pa5gprszifqz1lx9vg8h8nv-file-5.43"},
    "mesonFlags": {"type": "exported", "value": ""},
    "name": {"type": "exported", "value": "nix-shell"},
    "nativeBuildInputs": {"type": "exported", "value": ""},
    "out": {"type": "exported", "value": "/nix/store/3kkifha15mqxbwkvaafq3cf11ni5ipl6-nix-shell-env"},
    "outputBin": {"type": "var", "value": "out"},
    "outputDev": {"type": "var", "value": "out"},
    "outputDevdoc": {"type": "var", "value": "REMOVE"},
    "outputDevman": {"type": "var", "value": "out"},
    "outputDoc": {"type": "var", "value": "out"},
    "outputInclude": {"type": "var", "value": "out"},
    "outputInfo": {"type": "var", "value": "out"},
    "outputLib": {"type": "var", "value": "out"},
    "outputMan": {"type": "var", "value": "out"},
    "outputs": {"type": "exported", "value": "out"},
    "patches": {"type": "exported", "value": ""},
    "phases": {"type": "exported", "value": "buildPhase"},
    "pkg": {"type": "var", "value": "/nix/store/wzfrrcy9bawjvmz7wm4ms7mcymxw81bg-apple-framework-CoreFoundation-11.0.0"},
    "pkgsBuildBuild": {"type": "array", "value": []},
    "pkgsBuildHost": {"type": "array", "value": ["/nix/store/pnjndfczs1ggn962aalsdf5kxwqlsajg-hook" , "/nix/store/g0bmb8iq70gf1yk6pr50i2bp7gxfz77i-audit-tmpdir.sh" , "/nix/store/m54bmrhj6fqz8nds5zcj97w9s9bckc9v-compress-man-pages.sh" , "/nix/store/skk3q7jzy3yw80mdsq2lv0l4sr796xi2-make-symlinks-relative.sh" , "/nix/store/5yzw0vhkyszf2d179m0qfkgxmp5wjjx4-move-docs.sh" , "/nix/store/fyaryjvghbkpfnsyw97hb3lyb37s1pd6-move-lib64.sh" , "/nix/store/kd4xwxjpjxi71jkm6ka0np72if9rm3y0-move-sbin.sh" , "/nix/store/pag6l61paj1dc9sv15l7bm5c17xn5kyk-move-systemd-user-units.sh" , "/nix/store/yf7nb1zp58jvdl4zw8jkcpwpmq3yxpjz-multiple-outputs.sh" , "/nix/store/bnj8d7mvbkg3vdb07yz74yhl3g107qq5-patch-shebangs.sh" , "/nix/store/cickvswrvann041nqxb0rxilc46svw1n-prune-libtool-files.sh" , "/nix/store/wlwcf1nw2b21m4gghj70hbg1v7x53ld8-reproducible-builds.sh" , "/nix/store/ngg1cv31c8c7bcm2n8ww4g06nq7s4zhm-set-source-date-epoch-to-latest.sh" , "/nix/store/fmsdxxw5kg6s73hymvynw4jyxknkzqcp-strip.sh" , "/nix/store/bwscr98440mhhlg556fqhp5ll2fxnfic-clang-wrapper-11.1.0" , "/nix/store/xh503dqb1yb5w9mjziclp81gi4cqmwf6-cctools-binutils-darwin-wrapper-973.0.1" ]},
    "pkgsBuildTarget": {"type": "array", "value": []},
    "pkgsHostHost": {"type": "array", "value": ["/nix/store/5sby1xhsk6dzi83lsfrxp3w2hz32r3j7-libcxx-11.1.0-dev" , "/nix/store/qz1rmnp4y95qr0ikz0v0xr87fbwrvv74-libcxx-11.1.0" , "/nix/store/29095kfx46cjahphxf51w5mz5y38m7ap-libcxxabi-11.1.0-dev" , "/nix/store/6351z3343l2s5i8599p29ypz1i2hb8xc-libcxxabi-11.1.0" , "/nix/store/gmyw9mm8d6xk53hksr51m611w5il4nxp-compiler-rt-libc-11.1.0-dev" , "/nix/store/l739pwvg27xp2gg8jncx1yzrhxy03my6-compiler-rt-libc-11.1.0" ]},
    "pkgsHostTarget": {"type": "array", "value": ["/nix/store/r01krwydyya0zkdc68qwp8j2i5lym0aq-nodejs-18.13.0" , "/nix/store/1zz60imv11dwbx3gk86cbkw825r4qc1g-yarn-1.22.19" , "/nix/store/02l1dpfsjjsym5y9kllgxgs4c3jgcxgl-jq-1.6-dev" , "/nix/store/5m5ibgyi5fl248wjh3rvclh636mrw87w-jq-1.6-bin" , "/nix/store/q31jcs8ri7a176nhj6jq2jnn9br9fgay-jq-1.6-lib" , "/nix/store/wzfrrcy9bawjvmz7wm4ms7mcymxw81bg-apple-framework-CoreFoundation-11.0.0" , "/nix/store/k1r23ygby2l7g7vz4na10c928873pgva-libobjc-11.0.0" ]},
    "pkgsTargetTarget": {"type": "array", "value": []},
    "postFixupHooks": {"type": "array", "value": ["_makeSymlinksRelative" , "_multioutPropagateDev" ]},
    "postUnpackHooks": {"type": "array", "value": ["_updateSourceDateEpochFromSourceRoot" ]},
    "preConfigureHooks": {"type": "array", "value": ["_multioutConfig" ]},
    "preConfigurePhases": {"type": "var", "value": " updateAutotoolsGnuConfigScriptsPhase"},
    "preFixupHooks": {"type": "array", "value": ["_moveToShare" , "_multioutDocs" , "_multioutDevs" ]},
    "prefix": {"type": "var", "value": "/nix/store/3kkifha15mqxbwkvaafq3cf11ni5ipl6-nix-shell-env"},
    "propagatedBuildDepFiles": {"type": "array", "value": ["propagated-build-build-deps" , "propagated-native-build-inputs" , "propagated-build-target-deps" ]},
    "propagatedBuildInputs": {"type": "exported", "value": ""},
    "propagatedHostDepFiles": {"type": "array", "value": ["propagated-host-host-deps" , "propagated-build-inputs" ]},
    "propagatedNativeBuildInputs": {"type": "exported", "value": ""},
    "propagatedTargetDepFiles": {"type": "array", "value": ["propagated-target-target-deps" ]},
    "shell": {"type": "exported", "value": "/nix/store/n0k8njvgg6yjapkl81rm821s9vx0qrwb-bash-5.2-p15/bin/bash"},
    "shellHook": {"type": "exported", "value": "    export PATH=\"$PWD/node_modules/.bin/:$PATH\"\n    alias scripts='jq \".scripts\" package.json'\n\t\talias run='npm run'\n    alias g='git' \\\n        ga='g add' \\\n        gl='g pull' \\\n        gf='g fetch' \\\n        gp='g push' \\\n        gst='g status' \\\n        gcm='g commit -m' \\\n        gcmsg='g add -A; g commit -am'\n"},
    "stdenv": {"type": "exported", "value": "/nix/store/11kqdpgbaj7d3vp6kn5d35jspg5isjzv-stdenv-darwin"},
    "strictDeps": {"type": "exported", "value": ""},
    "stripAllFlags": {"type": "var", "value": " "},
    "system": {"type": "exported", "value": "aarch64-darwin"},
    "unpackCmdHooks": {"type": "array", "value": ["_defaultUnpack" ]}
  }
}